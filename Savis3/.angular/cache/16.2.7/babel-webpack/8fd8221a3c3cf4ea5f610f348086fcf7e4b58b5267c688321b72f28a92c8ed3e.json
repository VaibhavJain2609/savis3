{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class CalculationService {\n  constructor() {}\n  generateLabels(noOfCoin) {\n    const labels = new Array(noOfCoin + 1);\n    for (let i = 0; i <= noOfCoin; i++) {\n      labels[i] = i;\n    }\n    return labels;\n  }\n  calculateBinomial(noOfCoin, probability, totalSamples) {\n    const coeff = new Array(noOfCoin + 1).fill(0);\n    coeff[0] = 1;\n    const binomialBase = new Array(noOfCoin + 1);\n    binomialBase[0] = Math.pow(1 - probability, noOfCoin);\n    for (let i = 1; i <= noOfCoin; i++) {\n      coeff[i] = coeff[i - 1] * (noOfCoin + 1 - i) / i;\n      binomialBase[i] = coeff[i] * Math.pow(1 - probability, noOfCoin - i) * Math.pow(probability, i);\n    }\n    return binomialBase.map(x => x * totalSamples);\n  }\n  drawSamples(probability, noOfCoin, noOfDraw) {\n    const drawResults = new Array(noOfDraw);\n    for (let i = 0; i < noOfDraw; i++) {\n      drawResults[i] = new Array(noOfCoin).fill(NaN).map(() => Math.random() < probability ? 1 : 0);\n    }\n    return drawResults;\n  }\n  calculateMean(sampleData) {\n    const total = sampleData.reduce((acc, x) => acc + x, 0);\n    return sampleData.reduce((acc, x, i) => acc + x * i, 0) / total;\n  }\n  calculateStd(sampleData) {\n    const mean = this.calculateMean(sampleData);\n    const variance = sampleData.reduce((acc, x, i) => acc + (i - mean) ** 2 * x, 0) / (sampleData.reduce((acc, x) => acc + x, 0) - 1);\n    return Math.sqrt(variance);\n  }\n  calculateSamplesSelected(lower, upper, samples) {\n    lower = Math.max(lower, 0);\n    upper = Math.min(upper, samples.length);\n    return samples.reduce((acc, x, i) => {\n      if (i >= lower && i <= upper) {\n        return acc + x;\n      }\n      return acc;\n    }, 0);\n  }\n  generateSelectedArray(lower, upper, noOfCoin) {\n    lower = Math.max(lower, 0);\n    upper = Math.min(upper, noOfCoin + 2);\n    const selected = new Array(noOfCoin + 2).fill(NaN);\n    return selected.map((_, i) => {\n      if (i >= lower && i <= upper + 1) {\n        return 0;\n      }\n      return NaN;\n    });\n  }\n  addSamples(originalSamples, drawResults) {\n    const summary = drawResults.reduce((acc, eachDraw) => {\n      const noOfHead = eachDraw.reduce((accHeads, head) => accHeads + head, 0);\n      acc[noOfHead] = (acc[noOfHead] || 0) + 1;\n      return acc;\n    }, {});\n    return originalSamples.map((x, i) => x + (summary[i] || 0));\n  }\n  calculateSelectedProportion(selected, total) {\n    return selected / total;\n  }\n  static #_ = this.ɵfac = function CalculationService_Factory(t) {\n    return new (t || CalculationService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CalculationService,\n    factory: CalculationService.ɵfac,\n    providedIn: 'root'\n  });\n}","map":{"version":3,"names":["CalculationService","constructor","generateLabels","noOfCoin","labels","Array","i","calculateBinomial","probability","totalSamples","coeff","fill","binomialBase","Math","pow","map","x","drawSamples","noOfDraw","drawResults","NaN","random","calculateMean","sampleData","total","reduce","acc","calculateStd","mean","variance","sqrt","calculateSamplesSelected","lower","upper","samples","max","min","length","generateSelectedArray","selected","_","addSamples","originalSamples","summary","eachDraw","noOfHead","accHeads","head","calculateSelectedProportion","_2","factory","ɵfac","providedIn"],"sources":["/Users/bik/Downloads/School/CSC 190/SAVIS 3/savis3/Savis3/src/app/features/one-proportion/service/calculcation.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CalculationService {\n\n  constructor() { }\n\n  generateLabels(noOfCoin: number): number[] {\n    const labels = new Array(noOfCoin + 1);\n    for (let i = 0; i <= noOfCoin; i++) {\n      labels[i] = i;\n    }\n    return labels;\n  }\n\n  calculateBinomial(noOfCoin: number, probability: number, totalSamples: number): number[] {\n    const coeff = new Array(noOfCoin + 1).fill(0);\n    coeff[0] = 1;\n    const binomialBase = new Array(noOfCoin + 1);\n\n    binomialBase[0] = Math.pow(1 - probability, noOfCoin);\n\n    for (let i = 1; i <= noOfCoin; i++) {\n      coeff[i] = (coeff[i - 1] * (noOfCoin + 1 - i)) / i;\n      binomialBase[i] = coeff[i] * Math.pow(1 - probability, noOfCoin - i) * Math.pow(probability, i);\n    }\n\n    return binomialBase.map(x => x * totalSamples);\n  }\n\n  drawSamples(probability: number, noOfCoin: number, noOfDraw: number): number[][] {\n    const drawResults = new Array(noOfDraw);\n\n    for (let i = 0; i < noOfDraw; i++) {\n      drawResults[i] = new Array(noOfCoin).fill(NaN).map(() => Math.random() < probability ? 1 : 0);\n    }\n\n    return drawResults;\n  }\n\n  calculateMean(sampleData: number[]): number {\n    const total = sampleData.reduce((acc, x) => acc + x, 0);\n    return sampleData.reduce((acc, x, i) => acc + x * i, 0) / total;\n  }\n\n  calculateStd(sampleData: number[]): number {\n    const mean = this.calculateMean(sampleData);\n    const variance = sampleData.reduce((acc, x, i) => acc + (i - mean) ** 2 * x, 0) / (sampleData.reduce((acc, x) => acc + x, 0) - 1);\n    return Math.sqrt(variance);\n  }\n\n  calculateSamplesSelected(lower: number, upper: number, samples: number[]): number {\n    lower = Math.max(lower, 0);\n    upper = Math.min(upper, samples.length);\n\n    return samples.reduce((acc, x, i) => {\n      if (i >= lower && i <= upper) {\n        return acc + x;\n      }\n      return acc;\n    }, 0);\n  }\n\n  generateSelectedArray(lower: number, upper: number, noOfCoin: number): (number | typeof NaN)[] {\n    lower = Math.max(lower, 0);\n    upper = Math.min(upper, noOfCoin + 2);\n    const selected = new Array(noOfCoin + 2).fill(NaN);\n\n    return selected.map((_, i) => {\n      if (i >= lower && i <= upper + 1) {\n        return 0;\n      }\n      return NaN;\n    });\n  }\n\n  addSamples(originalSamples: number[], drawResults: number[][]): number[] {\n    const summary: { [key: number]:number } = drawResults.reduce((acc: { [key:number]: number }, eachDraw) => {\n      const noOfHead = eachDraw.reduce((accHeads, head) => accHeads + head, 0);\n      acc[noOfHead] = (acc[noOfHead] || 0) + 1;\n      return acc;\n    }, {});\n\n    return originalSamples.map((x, i) => x + (summary[i] || 0));\n  }\n\n  calculateSelectedProportion(selected: number, total: number): number {\n    return selected / total;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}